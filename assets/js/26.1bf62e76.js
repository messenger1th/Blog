(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{476:function(_,v,o){"use strict";o.r(v);var r=o(59),e=Object(r.a)({},(function(){var _=this,v=_.$createElement,o=_._self._c||v;return o("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[o("h1",{attrs:{id:"buffer-pool"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#buffer-pool"}},[_._v("#")]),_._v(" Buffer Pool")]),_._v(" "),o("p",[_._v("由于MySQL的数据存储在磁盘, 每次都从磁盘读取, 性能不高. 因此有了"),o("code",[_._v("Buffer Pool")]),_._v("的概念")]),_._v(" "),o("p",[_._v("有了缓冲池后：")]),_._v(" "),o("ul",[o("li",[_._v("当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。")]),_._v(" "),o("li",[_._v("当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。")])]),_._v(" "),o("h3",{attrs:{id:"buffer-pool-有多大"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#buffer-pool-有多大"}},[_._v("#")]),_._v(" Buffer Pool 有多大？")]),_._v(" "),o("p",[_._v("Buffer Pool 是在 MySQL 启动的时候，向操作系统申请的一片连续的内存空间，默认配置下 Buffer Pool 只有 "),o("code",[_._v("128MB")]),_._v(" 。")]),_._v(" "),o("p",[_._v("可以通过调整 "),o("code",[_._v("innodb_buffer_pool_size")]),_._v(" 参数来设置 Buffer Pool 的大小，一般建议设置成可用物理内存的 60%~80%。")]),_._v(" "),o("h3",{attrs:{id:"buffer-pool-缓存什么"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#buffer-pool-缓存什么"}},[_._v("#")]),_._v(" Buffer Pool 缓存什么？")]),_._v(" "),o("p",[_._v("InnoDB存储数据的单位是页, 默认16KB, 因此Buffer Pool也按页来划分.")]),_._v(" "),o("p",[_._v("在 MySQL 启动的时候，"),o("strong",[_._v("InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的"),o("code",[_._v("16KB")]),_._v("的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页")]),_._v("。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。")]),_._v(" "),o("p",[_._v("所以，MySQL 刚启动的时候，你会观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小，这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，接着将虚拟地址和物理地址建立映射关系。")]),_._v(" "),o("p",[_._v("Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 undo 页，插入缓存、自适应哈希索引、锁信息等等。")]),_._v(" "),o("img",{staticStyle:{zoom:"50%"},attrs:{src:"Buffer Pool.assets/bufferpool内容.drawio.png",alt:"img"}}),_._v(" "),o("p",[_._v("为了更好的管理这些在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一个"),o("strong",[_._v("控制块")]),_._v("，控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等。")]),_._v(" "),o("p",[_._v("控制块也是占有内存空间的，它是放在 Buffer Pool 的最前面，接着才是缓存页，如下图：")]),_._v(" "),o("p",[_._v("![img](Buffer Pool.assets/缓存页.drawio.png)")]),_._v(" "),o("p",[_._v("上图中控制块和缓存页之间灰色部分称为碎片空间。")]),_._v(" "),o("p",[o("strong",[_._v("为什么会有碎片空间呢？")])]),_._v(" "),o("p",[_._v("你想想啊，每一个控制块都对应一个缓存页，那在分配足够多的控制块和缓存页后，可能剩余的那点儿空间不够一对控制块和缓存页的大小，自然就用不到喽，这个用不到的那点儿内存空间就被称为碎片了。")]),_._v(" "),o("p",[_._v("当然，如果你把 Buffer Pool 的大小设置的刚刚好的话，也可能不会产生碎片。")]),_._v(" "),o("p",[o("strong",[_._v("查询一条记录，就只需要缓冲一条记录吗？")])]),_._v(" "),o("p",[_._v("不是的。")]),_._v(" "),o("p",[_._v("当我们查询一条记录时，InnoDB 是会把整个页的数据加载到 Buffer Pool 中，因为，通过索引只能定位到磁盘中的页，而不能定位到页中的一条记录。将页加载到 Buffer Pool 后，再通过页里的页目录去定位到某条具体的记录。")]),_._v(" "),o("p",[_._v("关于页结构长什么样和索引怎么查询数据的问题可以在这篇找到答案："),o("a",{attrs:{href:"https://mp.weixin.qq.com/s/A5gNVXMNE-iIlY3oofXtLw",target:"_blank",rel:"noopener noreferrer"}},[_._v("换一个角度看 B+ 树"),o("OutboundLink")],1)]),_._v(" "),o("h2",{attrs:{id:"如何管理-buffer-pool"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#如何管理-buffer-pool"}},[_._v("#")]),_._v(" 如何管理 Buffer Pool？")]),_._v(" "),o("h3",{attrs:{id:"如何管理空闲页"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#如何管理空闲页"}},[_._v("#")]),_._v(" 如何管理空闲页？")]),_._v(" "),o("p",[_._v("Buffer Pool 是一片连续的内存空间，当 MySQL 运行一段时间后，这片连续的内存空间中的缓存页既有空闲的，也有被使用的。")]),_._v(" "),o("p",[_._v("那当我们从磁盘读取数据的时候，总不能通过遍历这一片连续的内存空间来找到空闲的缓存页吧，这样效率太低了。")]),_._v(" "),o("p",[_._v("所以，为了能够快速找到空闲的缓存页，可以使用链表结构，将空闲缓存页的「控制块」作为链表的节点，这个链表称为 "),o("strong",[_._v("Free 链表")]),_._v("（空闲链表）。")]),_._v(" "),o("p",[_._v("![img](Buffer Pool.assets/freelist.drawio.png)")]),_._v(" "),o("p",[_._v("Free 链表上除了有控制块，还有一个头节点，该头节点包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息。")]),_._v(" "),o("p",[_._v("Free 链表节点是一个一个的控制块，而每个控制块包含着对应缓存页的地址，所以相当于 Free 链表节点都对应一个空闲的缓存页。")]),_._v(" "),o("p",[_._v("有了 Free 链表后，每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除。")]),_._v(" "),o("h3",{attrs:{id:"如何管理脏页"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#如何管理脏页"}},[_._v("#")]),_._v(" 如何管理脏页？")]),_._v(" "),o("p",[_._v("设计 Buffer Pool 除了能提高读性能，还能提高写性能，也就是更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为"),o("strong",[_._v("脏页")]),_._v("，然后再由后台线程将脏页写入到磁盘。")]),_._v(" "),o("p",[_._v("那为了能快速知道哪些缓存页是脏的，于是就设计出 "),o("strong",[_._v("Flush 链表")]),_._v("，它跟 Free 链表类似的，链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。")]),_._v(" "),o("img",{staticStyle:{zoom:"67%"},attrs:{src:"Buffer Pool.assets/Flush.drawio.png",alt:"img"}}),_._v(" "),o("p",[_._v("有了 Flush 链表后，后台线程就可以遍历 Flush 链表，将脏页写入到磁盘。")]),_._v(" "),o("h3",{attrs:{id:"如何提高缓冲命中率"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#如何提高缓冲命中率"}},[_._v("#")]),_._v(" 如何提高缓冲命中率")]),_._v(" "),o("p",[_._v("最容易想到的是 LRU("),o("em",[_._v("Least recently used")]),_._v(")算法.")]),_._v(" "),o("p",[_._v("但会出现一些问题")]),_._v(" "),o("ul",[o("li",[_._v("预读失败")]),_._v(" "),o("li",[_._v("Buffer Pool污染")])]),_._v(" "),o("p",[o("strong",[_._v("什么是预读失败?")])]),_._v(" "),o("p",[_._v("MySQL在加载数据页的时候, 由于程序的空间局部性的存在, 会将被访问数据的周围数据也加载进来, 以此减少磁盘I/O, 但是"),o("strong",[_._v("有可能这些数据没有被访问到")]),_._v(", 这就是"),o("strong",[_._v("预读失败")]),_._v(".")]),_._v(" "),o("p",[_._v("这些数据页加在头部, 可能一次性把末尾的页给淘汰. 由于程序的空间局部性原理仍然成立, 因此需要保留预读机制.")]),_._v(" "),o("p",[_._v("MySQL改进LRU算法, 将LRU划分成两个区域, "),o("strong",[_._v("old区域和young区域")])]),_._v(" "),o("p",[_._v("young在前, old在后优先被淘汰.")]),_._v(" "),o("p",[_._v("![img](Buffer Pool.assets/young%2Bold.png)")]),_._v(" "),o("p",[_._v("预读页加入到old区域的头部, 不影响young中高频使用的数据页.")]),_._v(" "),o("p",[_._v("访问到了才加到young区域.")]),_._v(" "),o("p",[o("strong",[_._v("什么是Buffer Pool污染")])]),_._v(" "),o("p",[_._v("短时间内访问了大量数据页, 导致Buffer Pool被这些仅访问一次的数据冲刷.")]),_._v(" "),o("p",[_._v("MySQL是这样处理的, 进入到yound区域的条件增加了一个停留在old区域的时间判断.")]),_._v(" "),o("p",[_._v("具体是这样做的，在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：")]),_._v(" "),o("ul",[o("li",[_._v("如果后续的访问时间与第一次访问的时间"),o("strong",[_._v("在某个时间间隔内")]),_._v("，那么"),o("strong",[_._v("该缓存页就不会被从 old 区域移动到 young 区域的头部")]),_._v("；")]),_._v(" "),o("li",[_._v("如果后续的访问时间与第一次访问的时间"),o("strong",[_._v("不在某个时间间隔内")]),_._v("，那么"),o("strong",[_._v("该缓存页移动到 young 区域的头部")]),_._v("；")])]),_._v(" "),o("p",[_._v("这个间隔时间是由 "),o("code",[_._v("innodb_old_blocks_time")]),_._v(" 控制的，默认是 1000 ms。")]),_._v(" "),o("p",[_._v("也就说，"),o("strong",[_._v("只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部")]),_._v("，这样就解决了 Buffer Pool 污染的问题 。")]),_._v(" "),o("p",[_._v("另外，MySQL 针对 young 区域其实做了一个优化，为了防止 young 区域节点频繁移动到头部。young 区域前面 1/4 被访问不会移动到链表头部，只有后面的 3/4被访问了才会。")]),_._v(" "),o("h2",{attrs:{id:"脏页什么时候刷入磁盘"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#脏页什么时候刷入磁盘"}},[_._v("#")]),_._v(" 脏页什么时候刷入磁盘?")]),_._v(" "),o("p",[_._v("InnoDB的更新操作采用的是"),o("em",[_._v("Write Ahead Log")]),_._v("即先写日志, 再写入磁盘, 通过redo log让MySQL拥有了奔溃恢复能力")]),_._v(" "),o("p",[_._v("下面几种情况会触发脏页刷新")]),_._v(" "),o("ul",[o("li",[_._v("redo log日志满了的情况")]),_._v(" "),o("li",[_._v("Buffer Pool空间不足, 会淘汰一部分数据页, 如果是脏页就同步到磁盘")]),_._v(" "),o("li",[_._v("MySQL认为空闲时")]),_._v(" "),o("li",[_._v("正常关闭时.")])]),_._v(" "),o("p",[_._v("在我们开启了慢 SQL 监控后，如果你发现**「偶尔」会出现一些用时稍长的 SQL**，这可能是因为脏页在刷新到磁盘时可能会给数据库带来性能开销，导致数据库操作抖动。")]),_._v(" "),o("p",[_._v("如果间断出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。")])])}),[],!1,null,null,null);v.default=e.exports}}]);