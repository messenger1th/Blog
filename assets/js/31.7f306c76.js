(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{481:function(_,v,e){"use strict";e.r(v);var t=e(59),r=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"mysql存储的结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql存储的结构"}},[_._v("#")]),_._v(" MySQL存储的结构")]),_._v(" "),e("ul",[e("li",[_._v("记录: Record")]),_._v(" "),e("li",[_._v("页: Page")]),_._v(" "),e("li",[_._v("区: extent")]),_._v(" "),e("li",[_._v("组:")]),_._v(" "),e("li",[_._v("段: Segement")]),_._v(" "),e("li",[_._v("表: Table")]),_._v(" "),e("li",[_._v("库")])]),_._v(" "),e("h2",{attrs:{id:"记录-record"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#记录-record"}},[_._v("#")]),_._v(" 记录: Record")]),_._v(" "),e("p",[_._v("记录与记录之间连成"),e("strong",[_._v("单向链表")]),_._v(", 便于二分查找到页面最小记录向后遍历查询.")]),_._v(" "),e("h2",{attrs:{id:"页-page"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#页-page"}},[_._v("#")]),_._v(" 页: Page")]),_._v(" "),e("p",[_._v("这是MySQL存储最基本的单位, 一般为16KB, 页与页之间连成"),e("strong",[_._v("双向链表")]),_._v(", 便于双向查询.")]),_._v(" "),e("h2",{attrs:{id:"区-extent"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#区-extent"}},[_._v("#")]),_._v(" 区: Extent")]),_._v(" "),e("p",[_._v("对于16KB的页来说 连续的64个页就是一个区, 也就是说一个区默认占用1MB空间大小.")]),_._v(" "),e("p",[_._v("在表中数据量很大时, 为某个索引分配空间的时候就以区为单位分配, 甚至是一次分配多个区, 来减少磁盘I/O. "),e("strong",[_._v("但由于数据量较小时, 这种策略会造成存储空间浪费, 因此提出了"),e("code",[_._v("Fragment")]),_._v("碎片区的概念, 直属于表空间")])]),_._v(" "),e("h3",{attrs:{id:"区的分类-区有4种状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#区的分类-区有4种状态"}},[_._v("#")]),_._v(" 区的分类:区有4种状态")]),_._v(" "),e("ul",[e("li",[_._v("空闲区 "),e("em",[_._v("FREE")])]),_._v(" "),e("li",[_._v("有剩余页面的碎片区: "),e("em",[_._v("FREE FRAG")])]),_._v(" "),e("li",[_._v("没有剩余页面的碎片区 "),e("em",[_._v("FREE FRAG")])]),_._v(" "),e("li",[_._v("附属于某个段的区 "),e("em",[_._v("FSEG")])])]),_._v(" "),e("p",[_._v("每个区都对应一个XDES Entry结构, 这个结构记录了对应的区的一些属性![image-20220601213959673](Storage Structure.assets/image-20220601213959673.png)")]),_._v(" "),e("p",[_._v("区与区之间可以通过"),e("code",[_._v("List Node")]),_._v("中的来连成一个双向链表.")]),_._v(" "),e("p",[e("strong",[_._v("连成链表有什么特殊用处呢? 等谈到段的概念再来解释.")])]),_._v(" "),e("h2",{attrs:{id:"组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组"}},[_._v("#")]),_._v(" 组")]),_._v(" "),e("p",[_._v("每256个区被划分为一个组.组的前几页是用于管理组的, 由于页面的大小有限, "),e("code",[_._v("XDES Entry")]),_._v("结构大小为40字节, 所以才把256个区分为一组, 在每组的第一个页面存放256个"),e("code",[_._v("XDES Entry")]),_._v(" 结构.")]),_._v(" "),e("p",[_._v("此外, 由于第一个组的第一个页面有些特殊, 它也是整个表空间的第一个页面, 因此也记录的表空间的一些属性, 为了区分命名, 将其命名为"),e("code",[_._v("FSP_HDR")]),_._v(", 含有"),e("code",[_._v("File Space Header")]),_._v("等, 其他部分与"),e("code",[_._v("XDES")]),_._v("差不多.")]),_._v(" "),e("p",[_._v("此外, 索引页和数据页分开在不同的区, 存放叶子节点的区的集合算是一个段, 存放非叶子节点的区的集合也算是一个段.")]),_._v(" "),e("h2",{attrs:{id:"段-segment"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#段-segment"}},[_._v("#")]),_._v(" 段: Segment")]),_._v(" "),e("p",[_._v("段不是一个物理上的区域, 是一个逻辑上的概念,由"),e("strong",[_._v("一些完整的区和若干零散页面组成")]),_._v(".")]),_._v(" "),e("p",[_._v("像每个区都有对应的"),e("code",[_._v("XDES Entry")]),_._v("来记录这个区的属性一样, InnoDB的设计者为每个段都定义了一个"),e("code",[_._v("INODE Entry")]),_._v("来记录这个段的属性, 方便管理段.")]),_._v(" "),e("p",[_._v("第一个分组中的第三个页面类型是"),e("code",[_._v("INODE")]),_._v(", 用于存储"),e("code",[_._v("INODE Entry")]),_._v(".")]),_._v(" "),e("p",[_._v("![image-20220602081744949](Storage Structure.assets/image-20220602081744949.png)")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("Segment ID")]),_._v(": 记录段的编号")]),_._v(" "),e("li",[e("code",[_._v("NOT_FULL_N_USED")]),_._v(": 在"),e("code",[_._v("NOT_FULL")]),_._v("链表中已经使用了多少个页面")]),_._v(" "),e("li",[_._v("3个"),e("code",[_._v("List Base Node")]),_._v("分别为段的"),e("code",[_._v("FREE")]),_._v(","),e("code",[_._v("NOT_FULL")]),_._v(","),e("code",[_._v("FULL")]),_._v("链表的头节点和尾节点")]),_._v(" "),e("li",[e("code",[_._v("Magic Number")]),_._v(": 用来标记这个INODE Entry是否已经被初始化.")]),_._v(" "),e("li",[e("code",[_._v("Framgent Array Entry")]),_._v(": 对应一些零散的页面, 表示一些零散的页面页号.")])]),_._v(" "),e("p",[e("strong",[_._v("如何快速定位各种状态的区呢?")])]),_._v(" "),e("p",[_._v("前面提到各种状态的区会通过"),e("code",[_._v("List Node")]),_._v("连成链表, 通过三种"),e("code",[_._v("List Base Node")]),_._v("可以快速定位在段中各种不同状态的区的头节点, 从而快速获取需要的区来存储数据.")]),_._v(" "),e("p",[_._v("每一个索引都对应两个段 每个段都会维护如下个链表.")]),_._v(" "),e("ul",[e("li",[_._v("Free 链表")]),_._v(" "),e("li",[_._v("NOT_FULL 链表")]),_._v(" "),e("li",[_._v("FULL链表")])]),_._v(" "),e("p",[_._v("​\t"),e("strong",[_._v("这就可以快速定位需要的区, 使用该页面后, 页面的状态改变, 继而从该状态的链表移动到转换后状态的链表.")])]),_._v(" "),e("p",[_._v("![image-20220602085659058](Storage Structure.assets/image-20220602085659058.png)")]),_._v(" "),e("p",[_._v("如图中描述, .每个"),e("code",[_._v("INODE Entry")]),_._v(" 结构占用 192 字节 个页面中可以存储 85 个这样的结构. "),e("strong",[_._v("那如果该结构不够用了怎么办?")])]),_._v(" "),e("p",[_._v("类似段中的三种区域链表, 将是否有空闲"),e("code",[_._v("INODE Entry")]),_._v("结构分成2类, 用"),e("code",[_._v("SEG_INODES_FULL")]),_._v("和"),e("code",[_._v("SEG_INDOE_FREE")]),_._v("链表连接起来, 基节点位于"),e("code",[_._v("FSP_HDR")]),_._v("类型页面的"),e("code",[_._v("File Space Header")]),_._v("中")]),_._v(" "),e("p",[e("strong",[_._v("说到这里, 我们来总结一下共有哪些结构连成了链表吧")])]),_._v(" "),e("ul",[e("li",[_._v("便于表空间管理段, 第一个组中的第第一个区的第一个页面, 即"),e("code",[_._v("FSP_HDR")]),_._v("页面里头的"),e("code",[_._v("File Space Header")]),_._v(" , 将每个段的"),e("code",[_._v("INODE")]),_._v("以是否有空闲的"),e("code",[_._v("INODE Entry")]),_._v("分类, 连成两条链表"),e("code",[_._v("SEG_INODE_FULL")]),_._v("和"),e("code",[_._v("SGE_INODE_FREE")]),_._v("链表.")]),_._v(" "),e("li",[_._v("便于段管理使用区, 段中的"),e("code",[_._v("INODE Entry")]),_._v("中记录了三种状态的区域的基节点, "),e("code",[_._v("FREE")]),_._v(", "),e("code",[_._v("NOT_FULL")]),_._v("和"),e("code",[_._v("Full")]),_._v("链表")]),_._v(" "),e("li",[_._v("页面之间形成双向链表")]),_._v(" "),e("li",[_._v("页面中的记录之间形成单向链表.")])]),_._v(" "),e("p",[_._v("此外, 由于段的三种区存储空间是从表空间分配而来, 因此")]),_._v(" "),e("ul",[e("li",[_._v("表空间也有三种链表"),e("code",[_._v("FREE")]),_._v(", "),e("code",[_._v("FREE_FRAG")]),_._v("和"),e("code",[_._v("FULL_FRAG")]),_._v("链表, 基节点位于"),e("code",[_._v("FSP_HDR")]),_._v("页面的"),e("code",[_._v("File Space Header")]),_._v(", 便于管理分配各种区.")])]),_._v(" "),e("h2",{attrs:{id:"other-tips"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#other-tips"}},[_._v("#")]),_._v(" Other Tips")]),_._v(" "),e("p",[_._v("我们知道，一个索引会产生两个段，分别是叶子节点段和非叶子节点段，而每个段都会对 应一个 "),e("code",[_._v("INODE")]),_._v("结构. "),e("strong",[_._v("我们 怎么知道某个段对应哪个"),e("code",[_._v("INODE Entry")]),_._v("结构呢?")])]),_._v(" "),e("p",[_._v("索引页(INDEX页) 中有一个"),e("code",[_._v("Page Header")]),_._v("部分")]),_._v(" "),e("p",[_._v("![image-20220602092951933](Storage Structure.assets/image-20220602092951933.png)")]),_._v(" "),e("p",[_._v("其中的 PAGE BTR_SEG_LEAF PAGE_BTR_SEG_TOP 都占用 10 字节，它们其实对应一个名为 Segmen Header 的结构，如图 9- 所示.")]),_._v(" "),e("p",[_._v("![image-20220602093022807](Storage Structure.assets/image-20220602093022807.png)")]),_._v(" "),e("p",[_._v("这样就很清晰了， "),e("code",[_._v("Page_BTR_SEG_LEAF")]),_._v(" 记录着叶子节点段对应的 "),e("code",[_._v("INODE Entry")]),_._v("结构的 地址是哪个表空间中哪个页丽的哪个偏移量")]),_._v(" "),e("p",[e("code",[_._v("PAGE_BTR_SEG_TOP")]),_._v(" 记录着非叶子节点段对应 "),e("code",[_._v("INODE Entry")]),_._v("结构的地址是哪个表空间中哪个页面的哪个偏移量.")]),_._v(" "),e("p",[_._v("这样, 索引和对应的段的关系就建立起来了. 不过需要注意的点是, 因为一个索引只对应两个段，所以只需要在索引的根页面中记录这两个结构即可.")])])}),[],!1,null,null,null);v.default=r.exports}}]);