<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Lock | Epoch</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="./assets/img/logo.ico">
    <meta name="description" content="Epoch&#39;s Blog">
    <meta name="author" content="Epoch">
    <meta name="keywords" content="Epochs Blog Basted On VuePress.">
    
    <link rel="preload" href="/blog/assets/css/0.styles.19413b44.css" as="style"><link rel="preload" href="/blog/assets/js/app.a976d4b9.js" as="script"><link rel="preload" href="/blog/assets/js/2.077fc20b.js" as="script"><link rel="preload" href="/blog/assets/js/35.8e496e16.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.c59a72b7.js"><link rel="prefetch" href="/blog/assets/js/11.2f51997e.js"><link rel="prefetch" href="/blog/assets/js/12.4c6b6d39.js"><link rel="prefetch" href="/blog/assets/js/13.8c9bf63c.js"><link rel="prefetch" href="/blog/assets/js/14.375a22b6.js"><link rel="prefetch" href="/blog/assets/js/15.630ac74c.js"><link rel="prefetch" href="/blog/assets/js/16.f9efd192.js"><link rel="prefetch" href="/blog/assets/js/17.710968ef.js"><link rel="prefetch" href="/blog/assets/js/18.e98248c3.js"><link rel="prefetch" href="/blog/assets/js/19.4dca1550.js"><link rel="prefetch" href="/blog/assets/js/20.ed86343f.js"><link rel="prefetch" href="/blog/assets/js/21.501b2f8f.js"><link rel="prefetch" href="/blog/assets/js/22.d3b58b1c.js"><link rel="prefetch" href="/blog/assets/js/23.9bf8a256.js"><link rel="prefetch" href="/blog/assets/js/24.9b3b0f9c.js"><link rel="prefetch" href="/blog/assets/js/25.2f925885.js"><link rel="prefetch" href="/blog/assets/js/26.1bf62e76.js"><link rel="prefetch" href="/blog/assets/js/27.3f7bc42a.js"><link rel="prefetch" href="/blog/assets/js/28.8bb4c4dd.js"><link rel="prefetch" href="/blog/assets/js/29.c6ffb896.js"><link rel="prefetch" href="/blog/assets/js/3.87def374.js"><link rel="prefetch" href="/blog/assets/js/30.98fc8e51.js"><link rel="prefetch" href="/blog/assets/js/31.7f306c76.js"><link rel="prefetch" href="/blog/assets/js/32.bf1c9517.js"><link rel="prefetch" href="/blog/assets/js/33.7e1a42c9.js"><link rel="prefetch" href="/blog/assets/js/34.49813caa.js"><link rel="prefetch" href="/blog/assets/js/36.c394458b.js"><link rel="prefetch" href="/blog/assets/js/37.409d9fcc.js"><link rel="prefetch" href="/blog/assets/js/38.4970fb9b.js"><link rel="prefetch" href="/blog/assets/js/4.4e1a7e2a.js"><link rel="prefetch" href="/blog/assets/js/5.f2ca250f.js"><link rel="prefetch" href="/blog/assets/js/6.db1d3ebc.js"><link rel="prefetch" href="/blog/assets/js/7.5a85f1a5.js"><link rel="prefetch" href="/blog/assets/js/8.1dbfb293.js"><link rel="prefetch" href="/blog/assets/js/9.168f1830.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.19413b44.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="./assets/img/logo.png" alt="Epoch" class="logo"> <span class="site-name can-hide">Epoch</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/CPP/C++ Primer.html" class="nav-link">
  CPP
</a></div><div class="nav-item"><a href="/blog/MySQL/" class="nav-link router-link-active">
  MySQL
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Internet" class="dropdown-title"><span class="title">Internet</span> <span class="arrow down"></span></button> <button type="button" aria-label="Internet" class="mobile-dropdown-title"><span class="title">Internet</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/Internet/Frame.html" class="nav-link">
  Frame
</a></li><li class="dropdown-item"><!----> <a href="/blog/Internet/HTTP/Http.html" class="nav-link">
  HTTP
</a></li><li class="dropdown-item"><!----> <a href="/blog/Internet/TCP&amp;IP/IP.html" class="nav-link">
  TCP&amp;IP
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="others" class="dropdown-title"><span class="title">others</span> <span class="arrow down"></span></button> <button type="button" aria-label="others" class="mobile-dropdown-title"><span class="title">others</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/others/Git.html" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/blog/others/Binary Tree Traversal.html" class="nav-link">
  Binary Tree Traversal
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/CPP/C++ Primer.html" class="nav-link">
  CPP
</a></div><div class="nav-item"><a href="/blog/MySQL/" class="nav-link router-link-active">
  MySQL
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Internet" class="dropdown-title"><span class="title">Internet</span> <span class="arrow down"></span></button> <button type="button" aria-label="Internet" class="mobile-dropdown-title"><span class="title">Internet</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/Internet/Frame.html" class="nav-link">
  Frame
</a></li><li class="dropdown-item"><!----> <a href="/blog/Internet/HTTP/Http.html" class="nav-link">
  HTTP
</a></li><li class="dropdown-item"><!----> <a href="/blog/Internet/TCP&amp;IP/IP.html" class="nav-link">
  TCP&amp;IP
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="others" class="dropdown-title"><span class="title">others</span> <span class="arrow down"></span></button> <button type="button" aria-label="others" class="mobile-dropdown-title"><span class="title">others</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/others/Git.html" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/blog/others/Binary Tree Traversal.html" class="nav-link">
  Binary Tree Traversal
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>My SQL</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/MySQL/" aria-current="page" class="sidebar-link">MySQL</a></li><li><a href="/blog/MySQL/Buffer Pool.html" class="sidebar-link">Buffer Pool</a></li><li><a href="/blog/MySQL/Relevant Question.html" class="sidebar-link">/MySQL/Relevant Question.html</a></li><li><a href="/blog/MySQL/事务.html" class="sidebar-link">事务</a></li><li><a href="/blog/MySQL/基础.html" class="sidebar-link">执行一条 SQL 查询语句，期间发生了什么？</a></li><li><a href="/blog/MySQL/存储结构.html" class="sidebar-link">MySQL存储的结构</a></li><li><a href="/blog/MySQL/开销.html" class="sidebar-link">开销</a></li><li><a href="/blog/MySQL/日志.html" class="sidebar-link">Redo Log: 重做日志</a></li><li><a href="/blog/MySQL/索引.html" class="sidebar-link">索引</a></li><li><a href="/blog/MySQL/锁.html" class="active sidebar-link">Lock</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/MySQL/锁.html#类型" class="sidebar-link">类型</a></li><li class="sidebar-sub-header"><a href="/blog/MySQL/锁.html#行级锁" class="sidebar-link">行级锁</a></li><li class="sidebar-sub-header"><a href="/blog/MySQL/锁.html#查询时加锁" class="sidebar-link">查询时加锁</a></li><li class="sidebar-sub-header"><a href="/blog/MySQL/锁.html#死锁-deadlock" class="sidebar-link">死锁:DeadLock</a></li><li class="sidebar-sub-header"><a href="/blog/MySQL/锁.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/blog/MySQL/锁.html#其他小知识" class="sidebar-link">其他小知识</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="lock"><a href="#lock" class="header-anchor">#</a> Lock</h1> <h2 id="类型"><a href="#类型" class="header-anchor">#</a> 类型</h2> <img src="lock.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70.png" alt="img" style="zoom:50%;"> <h3 id="全局锁"><a href="#全局锁" class="header-anchor">#</a> 全局锁</h3> <p>要使用全局锁，则要执行这条命：</p> <div class="language-mysql extra-class"><pre class="language-text"><code>flush tables with read lock
</code></pre></div><p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p> <ul><li>对数据的增删改操作，比如 insert、delete、update等语句；</li> <li>对表结构的更改操作，比如 alter table、drop table 等语句。</li></ul> <p>如果要释放全局锁，则要执行这条命令：</p> <div class="language-mysql extra-class"><pre class="language-text"><code>unlock tables
</code></pre></div><p><strong>应用场景</strong>:  <strong>全库逻辑备份</strong></p> <p>备份数据库的工具是 <code>mysqldump</code>，在使用 mysqldump 时加上 <code>–single-transaction</code> 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。</p> <p>InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。</p> <p>但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p> <h3 id="表级锁"><a href="#表级锁" class="header-anchor">#</a> 表级锁</h3> <blockquote><p>MySQL 表级锁有哪些？具体怎么用的。</p></blockquote> <p>MySQL 里面表级别的锁有这几种：</p> <ul><li>表锁；</li> <li>元数据锁（MDL）;</li> <li>意向锁；</li> <li>AUTO-INC 锁；</li></ul> <h4 id="表锁"><a href="#表锁" class="header-anchor">#</a> 表锁</h4> <p>先来说说<strong>表锁</strong>。</p> <p>如果我们想对学生表（t_student）加表锁，可以使用下面的命令：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">//表级别的共享锁，也就是读锁；</span>
<span class="token keyword">lock</span> <span class="token keyword">tables</span> t_student <span class="token keyword">read</span><span class="token punctuation">;</span>

<span class="token comment">//表级别的独占锁，也就是写锁；</span>
<span class="token keyword">lock</span> <span class="token keyword">tables</span> t_stuent wirte<span class="token punctuation">;</span>
</code></pre></div><p>需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p> <p>也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。</p> <p>要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">unlock</span> <span class="token keyword">tables</span>
</code></pre></div><p>另外，当会话退出后，也会释放所有表锁。</p> <p>不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，<strong>InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁</strong>。</p> <h4 id="元数据锁"><a href="#元数据锁" class="header-anchor">#</a> 元数据锁</h4> <p>再来说说<strong>元数据锁</strong>（MDL）。</p> <p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p> <ul><li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li> <li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li></ul> <p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p> <p>当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</p> <p>反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。</p> <blockquote><p>MDL 不需要显示调用，那它是在什么时候释放的?</p></blockquote> <p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p> <p>那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：</p> <ol><li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；</li> <li>然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；</li> <li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</li></ol> <p>那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</p> <blockquote><p>为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？</p></blockquote> <p>这是因为申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p> <p>所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。</p> <h4 id="意向锁"><a href="#意向锁" class="header-anchor">#</a> 意向锁</h4> <p>接着，说说<strong>意向锁</strong>。</p> <ul><li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li> <li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li></ul> <p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</p> <p>而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p> <p>不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">//先在表上加上意向共享锁，然后对读取的记录加共享锁</span>
<span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span>

<span class="token comment">//先表上加上意向独占锁，然后对读取的记录加独占锁</span>
<span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（*lock tables ... read*）和独占表锁（*lock tables ... write*）发生冲突。</strong></p> <p>表锁和行锁是满足读读共享、读写互斥、写写互斥的。</p> <p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p> <p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p> <p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p> <h3 id="auto-inc-锁"><a href="#auto-inc-锁" class="header-anchor">#</a> AUTO-INC 锁</h3> <p>最后，说说 <strong>AUTO-INC 锁</strong>。</p> <p>在为某个字段声明 <code>AUTO_INCREMENT</code> 属性时，之后可以在插入数据时，可以不指定该字段的值，数据库会自动给该字段赋值递增的值，这主要是通过 AUTO-INC 锁实现的。</p> <p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p> <p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p> <p>那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 <code>AUTO_INCREMENT</code> 修饰的字段的值是连续递增的。</p> <p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p> <p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。</p> <p>一样也是在插入数据的时候，会为被 <code>AUTO_INCREMENT</code> 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p> <p>InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。</p> <ul><li>当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁；</li> <li>当 innodb_autoinc_lock_mode = 2，就采用轻量级锁；</li> <li>当 innodb_autoinc_lock_mode = 1，这个是默认值，两种锁混着用，如果能够确定插入记录的数量就采用轻量级锁，不确定时就采用 AUTO-INC 锁。</li></ul> <p>不过，当 innodb_autoinc_lock_mode = 2 是性能最高的方式，但是会带来一定的问题。因为并发插入的存在，在每次插入时，自增长的值可能不是连续的，<strong>这在有主从复制的场景中是不安全的</strong>。</p> <h2 id="行级锁"><a href="#行级锁" class="header-anchor">#</a> 行级锁</h2> <p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。</p> <p>行级锁的类型主要有三类：</p> <ul><li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li> <li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li> <li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li></ul> <p>前面也提到，普通的 select 语句是不会对记录加锁的，如果要在查询时对记录加行锁，可以使用下面这两个方式：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">//对读取的记录加共享锁</span>
<span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span>

<span class="token comment">//对读取的记录加独占锁</span>
<span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre></div><p>上面这两条语句必须再一个事务中，当事务提交了，锁就会被释放，因此在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit = 0。</p> <p>那具体跟在哪些纪录上加锁，就跟具体的 select 语句有关系了，比较复杂。</p> <h2 id="查询时加锁"><a href="#查询时加锁" class="header-anchor">#</a> 查询时加锁</h2> <blockquote><p>分析加锁的原因: 从锁住搜索区间来考虑.</p></blockquote> <h3 id="唯一索引等值-单点-查询"><a href="#唯一索引等值-单点-查询" class="header-anchor">#</a> 唯一索引等值(单点)查询</h3> <blockquote><p>唯一索引等值查询, 可能是聚簇索引和二级唯一索引,</p></blockquote> <p>唯一索引等值查询分两种情况讨论</p> <ul><li>查询的记录存在, 只需加记录锁. 因为索引唯一, 只需要一条记录锁(next-key lock退化)就可以保证查询正确性.</li> <li>查询记录不存在, 需要加间隙锁. 记录不存在, 可能会新插入该记录导致查询错误, 因此需要间隙锁(next-key lock退化).</li></ul> <h3 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="header-anchor">#</a> 唯一索引范围查询</h3> <blockquote><p>要保证查询范围里头的记录不变, 因此查到没查到都需要加范围的锁(next-key或者间隙锁), 来包含住这个搜索区间, 以此保证搜索结果不变.</p></blockquote> <div class="language-mysql extra-class"><pre class="language-text"><code>select * from t_test where id&gt;=8 and id&lt;9 for update;
</code></pre></div><p><img src="lock.assets/image-20220531190324380.png" alt="image-20220531190324380"></p> <p>会话 1 加锁变化过程如下：</p> <ol><li>最开始要找的第一行是 id = 8，因此 next-key lock(4,8]，但是由于 id 是唯一索引，且该记录是存在的，因此会退化成记录锁，也就是只会对 id = 8 这一行加锁；</li> <li>由于是范围查找，就会继续往后找存在的记录，也就是会找到 id = 16 这一行停下来，然后加 next-key lock (8, 16]，但由于 id = 16 不满足 id &lt; 9，所以会退化成间隙锁，加锁范围变为 (8, 16)。</li></ol> <p>所以，会话 1 这时候主键索引的锁是记录锁 id=8 和间隙锁(8, 16), <strong>包含搜索区间[8, 9], 故可以保证正确性</strong>。</p> <p>会话 2 由于往间隙锁里插入了 id = 9 的记录，所以会被锁住了，而 id = 8 是被加锁的，因此会话 3 的语句也会被阻塞。</p> <p>由于 id = 16 并没有加锁，所以会话 4 是可以正常被执行。</p> <h3 id="非唯一索引等值查询"><a href="#非唯一索引等值查询" class="header-anchor">#</a> 非唯一索引等值查询</h3> <p>还是分两种情况:</p> <ul><li>当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁。<strong>因为索引不唯一, 所以需要延申到下一个索引处, 即加一个包含该点(点形成的索引区间)的间隙锁</strong></li> <li>当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁:<strong>即锁住这个点的索引区间即可</strong></li></ul> <p><strong>查询到的情况:</strong></p> <img src="lock.assets/be6818bd1fd22c4e790b989bde11e6b1.png" alt="图片" style="zoom:67%;"> <p>会话 1 加锁变化过程如下：</p> <ol><li>先会对普通索引 b 加上 next-key lock，范围是(4,8];</li> <li>然后因为是非唯一索引，且查询的记录是存在的，所以还会加上间隙锁，规则是向下遍历到第一个不符合条件的值才能停止，因此间隙锁的范围是(8,16)。</li></ol> <p>所以，会话1的普通索引 b 上共有两个锁，分别是 next-key lock (4,8] 和间隙锁 (8,16) 。<strong>锁住了[8, 8]这个搜索区间, 保证了正确性.</strong></p> <p>那么，当会话 2 往间隙锁里插入 id = 9 的记录就会被锁住，而会话 3 和会话 4 是因为更改了 next-key lock 范围里的记录而被锁住的。</p> <p>然后因为 b = 16 这条记录没有加锁，所以会话 5 是可以正常执行的。</p> <p><strong>未查询到: 就直接上间隙锁(由next-key退化)</strong></p> <h3 id="非唯一索引范围查询"><a href="#非唯一索引范围查询" class="header-anchor">#</a> 非唯一索引范围查询</h3> <blockquote><p>非唯一索引和主键索引的范围查询的加锁也有所不同，不同之处在于<strong>普通索引范围查询，next-key lock 不会退化为间隙锁和记录锁</strong></p></blockquote> <p><img src="lock.assets/ac6c09c4011259d3397e62e52a37d384.png" alt="图片"></p> <p>会话 1 加锁变化过程如下：</p> <ol><li>最开始要找的第一行是 b = 8，因此 next-key lock(4,8]，但是由于 b 不是唯一索引，并不会退化成记录锁。</li> <li>但是由于是范围查找，就会继续往后找存在的记录，也就是会找到 b = 16 这一行停下来，然后加 next-key lock (8, 16]，因为是普通索引查询，所以并不会退化成间隙锁。</li></ol> <p>所以，会话 1 的普通索引 b 有两个 next-key lock，分别是 (4,8] 和(8, 16]。<strong>即区间(4, 16], 包含搜索区间</strong>. 这样，你就明白为什么会话 2 、会话 3 、会话 4 的语句都会被锁住了。</p> <p>**注: ** 以上四种都是</p> <ol><li><strong>如果是二级索引, 还需要回表到聚簇索引给聚簇索引加相应的锁.</strong></li> <li>如果是聚簇索引, 并且更新了二级索引, 需要到相应二级索引上X锁.</li></ol> <p>为什么两边都要上锁呢?  考虑如下情况:</p> <p><strong>二级索引到聚簇索引的情况:</strong></p> <ul><li>二级索引查询, 若仅对二级索引上锁, 第一次查到一个记录符合条件, 给二级索引上相应的锁</li> <li>第二次查询之前, 有一个事务修改了上面符合条件的记录, 导致不符合条件.</li> <li>第二次查询时, 就出现了问题.</li></ul> <p><strong>聚簇索引到二级索引的情况:</strong></p> <ul><li>根据聚簇索引更新记录, 更新了二级索引, 更新前后读到的二级索引不一致.</li> <li>就出现了问题.</li></ul> <h2 id="死锁-deadlock"><a href="#死锁-deadlock" class="header-anchor">#</a> 死锁:DeadLock</h2> <p><img src="lock.assets/image-20220531203531847.png" alt="image-20220531203531847"></p> <ul><li>从③中可以看出. Tl 先对 number 值为 的聚簇索引记录加了一个 型正经记录锁</li> <li>从④中可以看出. T2 number 值为 的聚簇索引记录加了 型正经记录锁.</li> <li>从⑤中可以看出 TI 接着也想对 number 值为 的记录加 型正经记录锁，但是 与④中T2持有的锁冲突 所以 Tl 迸入阻塞状态，等待获取锁.</li> <li>从⑥中可以看出. T2也想对 number 值为 的记录加 型正经记录锁，但是与 T1 持有的锁冲突，所以T2迸入阻塞状态，等待获取锁.</li></ul> <p>死锁发生时 lnnoDB 会选择一个较小的事务进行回滚.</p> <p><strong>可以通过执行 <code>SHOW ENGINE INNODB STATUS</code> 语句来查看最近发生的一次死锁信息.</strong></p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <blockquote><p>图源:&lt;MySQL是怎样运行的&gt;</p></blockquote> <p><img src="lock.assets/image-20220531203929325.png" alt="image-20220531203929325"></p> <h2 id="其他小知识"><a href="#其他小知识" class="header-anchor">#</a> 其他小知识</h2> <ul><li>半一致性读</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">6/6/2022, 8:59:12 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/MySQL/索引.html" class="prev">
        索引
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.a976d4b9.js" defer></script><script src="/blog/assets/js/2.077fc20b.js" defer></script><script src="/blog/assets/js/35.8e496e16.js" defer></script>
  </body>
</html>
